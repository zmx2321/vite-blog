import{_ as s,o as n,c as l,e as a}from"./app.b389e2ff.js";const m=JSON.parse('{"title":"运行环境","description":"","frontmatter":{},"headers":[],"relativePath":"pages/interview/foundation/interview-foundation-16.md","filePath":"pages/interview/foundation/interview-foundation-16.md","lastUpdated":1699250630000}'),p={name:"pages/interview/foundation/interview-foundation-16.md"},o=a(`<h1 id="运行环境" tabindex="-1">运行环境 <a class="header-anchor" href="#运行环境" aria-label="Permalink to &quot;运行环境&quot;">​</a></h1><p><a href="https://zmx2321.github.io/blog_code/interview/interview-one-side/16.html" target="_blank" rel="noreferrer">代码笔记</a></p><h2 id="_1-简述" tabindex="-1">1. 简述 <a class="header-anchor" href="#_1-简述" aria-label="Permalink to &quot;1. 简述&quot;">​</a></h2><ul><li>运行环境即浏览器 <ul><li>server端有nodejs</li><li>移动端可能在微信、支付宝等app中运行页面，但这些实际上还是浏览器 <ul><li>比如说微信，他是以微信的功能为主，但他里面实际上嵌了webview模块，具备浏览器的功能</li></ul></li><li>即各种app对网页来说，都是浏览器</li></ul></li><li>浏览器要下载代码，渲染出页面，期间会执行若干JS <ul><li>前端和服务端最大的差别在于，他需要随时地下载网页代码、渲染</li><li>所以他对性能就需要比较高的要求 <ul><li>所以需要针对运行环境的特点来优化，如何让网页加载快一些</li></ul></li></ul></li><li>需要保证代码在浏览器中稳定而且高效</li></ul><h2 id="_2-题目" tabindex="-1">2. 题目 <a class="header-anchor" href="#_2-题目" aria-label="Permalink to &quot;2. 题目&quot;">​</a></h2><h3 id="_2-1-网页加载过程" tabindex="-1">2.1. 网页加载过程 <a class="header-anchor" href="#_2-1-网页加载过程" aria-label="Permalink to &quot;2.1. 网页加载过程&quot;">​</a></h3><ul><li>从输入url到渲染出页面的整个过程</li><li>window.onload和DOMContentLoaded的区别</li></ul><h3 id="_2-2-性能和体验的优化" tabindex="-1">2.2. 性能和体验的优化 <a class="header-anchor" href="#_2-2-性能和体验的优化" aria-label="Permalink to &quot;2.2. 性能和体验的优化&quot;">​</a></h3><ul><li>性能优化原则是什么</li><li>怎么样让加载更快，举例说明</li><li>怎么样让渲染更快，举例说明</li><li>防抖是什么，举例说明，手写防抖</li><li>节流是什么，举例说明，手写节流</li></ul><h3 id="_2-3-安全" tabindex="-1">2.3. 安全 <a class="header-anchor" href="#_2-3-安全" aria-label="Permalink to &quot;2.3. 安全&quot;">​</a></h3><ul><li>常见的web前端攻击方式有哪些</li><li>怎么去预防这些攻击</li></ul><h2 id="_3-知识点" tabindex="-1">3. 知识点 <a class="header-anchor" href="#_3-知识点" aria-label="Permalink to &quot;3. 知识点&quot;">​</a></h2><h3 id="_3-1-网页加载过程" tabindex="-1">3.1. 网页加载过程 <a class="header-anchor" href="#_3-1-网页加载过程" aria-label="Permalink to &quot;3.1. 网页加载过程&quot;">​</a></h3><h4 id="_3-1-1-加载资源的形式" tabindex="-1">3.1.1. 加载资源的形式 <a class="header-anchor" href="#_3-1-1-加载资源的形式" aria-label="Permalink to &quot;3.1.1. 加载资源的形式&quot;">​</a></h4><ul><li>html代码</li><li>媒体文件，如图片、视频等</li><li>js、css代码</li></ul><h4 id="_3-1-2-加载资源的过程" tabindex="-1">3.1.2. 加载资源的过程 <a class="header-anchor" href="#_3-1-2-加载资源的过程" aria-label="Permalink to &quot;3.1.2. 加载资源的过程&quot;">​</a></h4><ol><li>DNS解析：域名 =&gt; ip地址 <ul><li>Domain Name System =&gt; 域名系统</li><li>是将域名和IP地址相互映射的一个分布式数据库 <ul><li>我们访问域名的时候，实际上对应的还是ip地址</li></ul></li><li>特别是一个大型的网站，不同区域的服务端ip地址是不一样的，因为他们分区域做了ip地址的均衡或者代理</li><li>我们在输入域名的时候，域名解析服务会根据地域去解析不同的域名，网站会访问的更快一些</li></ul></li><li>浏览器根据ip地址向服务器发起http请求 <ul><li>发起请求</li><li>浏览器只是一个发起方，真正的核心模块还是操作系统，操作系统里面有一些能够发送网络请求的系统服务，浏览器调用这些系统服务，操作系统去把这个请求发送</li><li>我们这边说是http请求，实际上里面还涉及到TCP的连接(三次握手)</li></ul></li><li>服务器接收并处理http请求，返回给浏览器 <ul><li>响应请求</li><li>服务器如何接收并处理请求就是服务端的内容了(可以通过nodejs了解)</li></ul></li></ol><h4 id="_3-1-3-渲染页面的过程" tabindex="-1">3.1.3. 渲染页面的过程 <a class="header-anchor" href="#_3-1-3-渲染页面的过程" aria-label="Permalink to &quot;3.1.3. 渲染页面的过程&quot;">​</a></h4><ol><li>浏览器根据html代码生成DOM Tree <ul><li>document object model =&gt; 文档对象模型</li></ul></li><li>浏览器根据css代码生成cssOM <ul><li>css object model =&gt; css对象模型</li></ul></li><li>将DOM Tree和cssOM整合形成Render Tree <ul><li>Render Tree =&gt; 渲染树</li><li>只有dom树是没法渲染的，有些标签的css属性是在css对象模型中的 <ul><li>宽、高、颜色、字体大小等</li></ul></li><li>dom结构里面挂了很多css属性 <ul><li>每选一个节点，下面就有很多css属性</li></ul></li></ul></li><li>浏览器根据Render Tree渲染页面</li><li>如果遇到<code>&lt;script&gt;</code>则暂停渲染，优先加载并执行JS代码，完成再继续 <ul><li>js和渲染是共用一个线程的，因为js有可能会改变dom结构，即Render Tree结构</li><li>渲染过程中遇到<code>&lt;script&gt;</code>标签，就不渲染了，因为可能没有用，因为js可能改变dom结构，这就是遇到<code>&lt;script&gt;</code>标签先执行js代码的由来，执行完js之后再继续进行渲染</li></ul></li><li>直至把Render Tree渲染完成</li></ol><h4 id="_3-1-4-总结" tabindex="-1">3.1.4. 总结 <a class="header-anchor" href="#_3-1-4-总结" aria-label="Permalink to &quot;3.1.4. 总结&quot;">​</a></h4><ul><li>为何把css放到head中 <ul><li>html页面是从上往下执行的，如果把css放到下面，渲染完成dom之后，又发现css，css加载完成之后，形成cssOM，又和当前的dom树合并形成render tree，改变样式之后，可能会重新渲染dom树</li><li>从上至下正常渲染dom，发现css，样式改变，比如字体大小，重新渲染改变字体大小</li><li>css放到head中是为了dom树生成完之前就加载完，dom树生成完之后就和所有的css整合生成一个完整的render tree，即一步渲染完成</li></ul></li><li>为何要把js放到body下面 <ul><li>遇到js之后，要暂停渲染，执行完js之后才继续渲染</li><li>js可能会修改dom结构，如果放在中间，可能会出错</li><li>渲染了一部分，会停止渲染，即卡住的状态</li><li>会造成页面的渲染过程比较长</li><li>我们需要把先能渲染出来的东西全部渲染出来</li></ul></li><li>遇到img标签 <ul><li>不会阻塞渲染过程，img资源没过来会先空着</li></ul></li><li>window.onload和DOMContentLoaded<div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">window.</span><span style="color:#B392F0;">addEventListener</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;load&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 页面的全部资源加载完才会执行，包括图片、视频等</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// iframe也会这样</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">document.</span><span style="color:#B392F0;">addEventListener</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;DOMContentLoaded&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// DOM 渲染完即可执行(网页加载完了)，此时图片、视频还可能没有加载完</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 像jquery都是要监听DOMContentLoaded事件做一些处理</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">window.</span><span style="color:#6F42C1;">addEventListener</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;load&#39;</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">function</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 页面的全部资源加载完才会执行，包括图片、视频等</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// iframe也会这样</span></span>
<span class="line"><span style="color:#24292E;">})</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">document.</span><span style="color:#6F42C1;">addEventListener</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;DOMContentLoaded&#39;</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">function</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// DOM 渲染完即可执行(网页加载完了)，此时图片、视频还可能没有加载完</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 像jquery都是要监听DOMContentLoaded事件做一些处理</span></span>
<span class="line"><span style="color:#24292E;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li></ul><h3 id="_3-2-性能和体验的优化" tabindex="-1">3.2. 性能和体验的优化 <a class="header-anchor" href="#_3-2-性能和体验的优化" aria-label="Permalink to &quot;3.2. 性能和体验的优化&quot;">​</a></h3><h4 id="_3-2-1-简述" tabindex="-1">3.2.1. 简述 <a class="header-anchor" href="#_3-2-1-简述" aria-label="Permalink to &quot;3.2.1. 简述&quot;">​</a></h4><ul><li>性能优化是一个综合性问题，没有标准答案，但要求尽量全面</li><li>某些细节问题可能会单独提问：手写防抖、节流 <ul><li>属于体验上的优化</li></ul></li><li>只关注核心点、针对面试</li><li>性能优化原则 <ul><li>多使用内存、缓存、或其他方法</li><li>减少CPU计算量，减少网络加载耗时</li></ul></li><li>性能优化主要目的就是使页面加载更快更流畅 <ul><li>适用所有编程的性能优化 - 空间换时间</li><li>比如Chrome浏览器加载很快，就是因为它使用了空间换时间的概念 <ul><li>比如标签页，一般浏览器都放在同一个进程中，而Chrome浏览器的思路就是每个标签页都有一个单独的进程，这样空间就使用地多了，但速度也更快了，进程和进程之间不会相互干扰，标签页之间也不会相互干扰，每个标签页，可利用的空间也多了，空间多了，就可以用空间换时间，从而加载更快</li><li>历史背景：在Chrome之前的很多浏览器，计算机的内存空间不宽裕</li></ul></li></ul></li><li>从哪里入手 <ul><li>让加载更快 <ul><li>下载速度更快</li></ul></li><li>让渲染更快 <ul><li>代码逻辑合理，没有重复多余的渲染操作，没有等待</li><li>至少在同一时间内，让用户看到的更快</li></ul></li></ul></li></ul><h4 id="_3-2-2-让加载更快" tabindex="-1">3.2.2. 让加载更快 <a class="header-anchor" href="#_3-2-2-让加载更快" aria-label="Permalink to &quot;3.2.2. 让加载更快&quot;">​</a></h4><ul><li>减少资源体积，压缩代码 <ul><li>服务端会进行gzip压缩，大概到1/3 =&gt; 10kb到3kb</li><li>浏览器再进行反解析</li><li>这里只是引申，不是前端范围</li></ul></li><li>减少访问次数 <ul><li>合并代码、ssr服务端渲染、缓存</li><li>合并代码 <ul><li>很多js文件，webpack打包完之后，只有几个，即合并代码 <ul><li>合并完代码之后，就可以减少访问次数</li><li>三个文件，每个文件3kb，分别访问3kb比一次性访问9kb更耗时</li></ul></li><li>图片，css也可以压缩 <ul><li>雪碧图也是减少访问次数的一个示例</li></ul></li></ul></li><li>ssr服务端渲染 <ul><li>服务端渲染指服务端把页面以及页面要显示的内容一块给前端，前端拿到内容之后就直接展示</li><li>不使用服务端渲染的话，即传统方法是，把页面拿到之后，再通过ajax加载资源，加载资源之后再去下载资源，下载完之后再渲染到页面上去</li></ul></li><li>缓存 <ul><li>如果页面要访问10个资源，如果没有缓存，就要请求10次，如果有缓存，那么命中缓存的那些资源就不需要重复请求</li></ul></li></ul></li><li>使用更快的网络：CDN <ul><li>CDN是根据区域去做服务器的处理</li><li>即如果使用cdn，从北京访问的ip和从上海访问的ip是不一样的</li></ul></li></ul><h4 id="_3-2-3-让渲染更快" tabindex="-1">3.2.3. 让渲染更快 <a class="header-anchor" href="#_3-2-3-让渲染更快" aria-label="Permalink to &quot;3.2.3. 让渲染更快&quot;">​</a></h4><ul><li>CSS放在head，JS放在body最下面</li><li>尽早执行JS，用DOMContentLoaded触发 <ul><li>js尽早执行，没必要等图片、视频等资源加载完成，即onload</li></ul></li><li>懒加载 <ul><li>图片懒加载，上滑加载更多</li></ul></li><li>对DOM查询进行缓存</li><li>频繁DOM操作，使用代码片段合并到一起插入DOM结构 <ul><li>createDocumentFragment</li></ul></li><li>节流(throttle)、防抖(debounce) <ul><li>让渲染更加流畅</li></ul></li></ul><h4 id="_3-2-4-加载渲染优化示例" tabindex="-1">3.2.4. 加载渲染优化示例 <a class="header-anchor" href="#_3-2-4-加载渲染优化示例" aria-label="Permalink to &quot;3.2.4. 加载渲染优化示例&quot;">​</a></h4><ul><li>资源合并 <ul><li>请求次数越少越划算 <img src="https://zmx2321.github.io/vite-blog/images/interview/foundation/yh_zyhb.png" alt="yh_zyhb"></li></ul></li><li>缓存 <ul><li>webpack中的contenthash会根据内容生成hash值</li><li>静态资源加hash后缀，根据文件内容计算hash</li><li>文件内容不变，则hash不变，则url不变</li><li>url和文件不变，则会自动触发http缓存机制，返回304</li><li>浏览器和服务器都会遵从http缓存机制，前端只需要尽可能去命中这个缓存就行了</li><li>比如新上线一个功能，只改了一个js，这时候只有一个js名字会改，返回200，其余的都不变，不变的资源加载会命中缓存，返回304 <img src="https://zmx2321.github.io/vite-blog/images/interview/foundation/yh_hc.png" alt="yh_hc"></li></ul></li><li>CDN <ul><li>大厂静态资源基本都是用cdn做的</li><li>用cdn会更大程度满足网络的性能</li><li>因为cdn是专门做静态文件的服务</li><li>而且是根据地域来做网络服务的</li><li>而且cdn是完全满足上面说的http缓存机制(304机制)的 <img src="https://zmx2321.github.io/vite-blog/images/interview/foundation/yh_cdn.png" alt="yh_cdn"></li></ul></li><li>SSR <ul><li>是一个比较宽泛的概念，全称是：server side render，即服务端渲染</li><li>服务端渲染：将网页和数据一起加载、一起渲染</li><li>非SSR(前后端分离)：先加载网页，再加载数据，再渲染数据 <ul><li>网页的ajax去加载数据，数据返回之后再渲染</li></ul></li><li>所以ssr也是减少网络请求的一种思路</li><li>早先的JSP、ASP、PHP，现在的vue、react(借助node的一些能力做)</li></ul></li><li>懒加载 <ul><li>有时候需要在可视区域加载，不在可视区的暂时不加载</li><li>我们可以把图片设置成一个默认地址(小)</li><li>把图片的真实地址放到<code>data-xxx</code>下面，在这里图片不会加载</li><li>根据事件判断到可视区的时候，把<code>data-xxx</code>的值赋值给src <img src="https://zmx2321.github.io/vite-blog/images/interview/foundation/yh_ljz.png" alt="yh_ljz"></li></ul></li><li>缓存DOM查询 <ul><li>把dom结果赋值成变量</li><li>js计算和dom查询不是一个数量级的，js计算非常快 <img src="https://zmx2321.github.io/vite-blog/images/interview/foundation/yh_dom1.png" alt="yh_dom1"></li><li>多个dom操作一起插入到dom结构，使用代码片段 <img src="https://zmx2321.github.io/vite-blog/images/interview/foundation/yh_dom2.png" alt="yh_dom2"></li></ul></li><li>尽早开始js执行 <img src="https://zmx2321.github.io/vite-blog/images/interview/foundation/yh_js.png" alt="yh_js"></li></ul><h4 id="_3-2-5-防抖-debounce" tabindex="-1">3.2.5. 防抖(debounce) <a class="header-anchor" href="#_3-2-5-防抖-debounce" aria-label="Permalink to &quot;3.2.5. 防抖(debounce)&quot;">​</a></h4><ul><li>场景 <ul><li>监听一个输入框的，在文字变化后触发change事件</li><li>直接使用keyup事件，会频繁触发change事件</li><li>防抖：用户输入结束或暂停的时候，才会触发change事件</li></ul></li><li>防抖机制简述 <ul><li>防抖机制指的是频繁输入或者频繁操作的时候，最后触发</li><li>先定义一个定时器</li><li>监听事件的时候，最开始是没有这个定时器的(null)</li><li>给定时器赋值 <ul><li>setTimeout会返回一个定时器的id</li><li>给定时器赋值，同时触发一个setTimeout的异步任务</li><li>这个任务是xx毫秒之后执行</li><li>执行的结果就是定时器里面的方法</li></ul></li><li>执行完定时器里的方法之后还要在方法里面清空定时器 <ul><li>xx毫秒触发方法之后，才会清空timer</li></ul></li></ul></li><li>手写防抖 <ul><li><a href="https://zmx2321.github.io/blog_code/interview/interview-one-side/example/run-fun/%E9%98%B2%E6%8A%96(debounce).html" target="_blank" rel="noreferrer">手写demo传送门</a></li></ul><div class="language-html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">input</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">type</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;text&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">id</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;input1&quot;</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 监听键盘输入</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">/* const input1 = document.getElementById(&#39;input1&#39;);</span></span>
<span class="line"><span style="color:#6A737D;">  input1.addEventListener(&#39;keyup&#39;, function() {</span></span>
<span class="line"><span style="color:#6A737D;">      console.log(input1.value);  // 每一次按键都会打印</span></span>
<span class="line"><span style="color:#6A737D;">  }) */</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;">   * 体验防抖</span></span>
<span class="line"><span style="color:#6A737D;">   */</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 如果每次按键都走一次请求会非常糟糕</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 实现输入完停顿一段时间(比如半秒)，再做操作(打印或者请求)</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 这个机制(需求)就是防抖</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 需要用到定时器 =&gt; 实际上就是定时器的一种应用</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">input1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> document.</span><span style="color:#B392F0;">getElementById</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;input1&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> timer  </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  input1.</span><span style="color:#B392F0;">addEventListener</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;keyup&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 比如输入123,</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 输入1，此时timeer不存在，timer赋值定时器id(1)，并把方法加入异步队列，等待时机执行</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 马上输入2，此时timer存在，但异步队列中的方法还未执行(时机未到)，清除定时器(即1的定时任务)，赋值定时器id(2)，，并把方法加入异步队列，等待时机执行</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 马上输入3，同理</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 停止输入，即超过500毫秒，触发定时器任务，获取value值并打印</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 清空定时器</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(timer) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#B392F0;">clearTimeout</span><span style="color:#E1E4E8;">(timer)</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 一直输入，只要中间间断不超过500毫秒，就不会打印</span></span>
<span class="line"><span style="color:#E1E4E8;">    timer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">setTimeout</span><span style="color:#E1E4E8;">(()</span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 模拟触发change事件</span></span>
<span class="line"><span style="color:#E1E4E8;">      console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(input1.value);  </span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 清空定时器</span></span>
<span class="line"><span style="color:#E1E4E8;">      timer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span></span>
<span class="line"><span style="color:#E1E4E8;">    }, </span><span style="color:#79B8FF;">500</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">  })</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;">   * 封装防抖</span></span>
<span class="line"><span style="color:#6A737D;">   */</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// debounce是对函数的封装，最终返回的应该也是一个函数</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 延迟时间默认500毫秒</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">debounce</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">fn</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">delay</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">500</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// timer是在闭包中的 =&gt; 下面的if(timer)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 这样不会被外界轻易拿到 =&gt; 即不对外暴露</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 我们在外面使用不需要关心</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 同时也是在debounce的作用域中</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 闭包的使用场景：函数当做返回值或者参数传入</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> timer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 函数作为返回值，这就形成闭包了</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 这里面的timer需要在它定义的作用域往上寻找</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(timer) {</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#B392F0;">clearTimeout</span><span style="color:#E1E4E8;">(timer)</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">      timer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">setTimeout</span><span style="color:#E1E4E8;">(()</span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 触发change事件</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 第一个参数是改变this指向</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 第二个参数是获取所有的参数</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// apply第二个参数开始，只接收数组</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// fn函数在执行的时候，argument传进来</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// debounce返回的函数可能会传进来一些参数</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 面试使用fn()也没问题</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// fn()</span></span>
<span class="line"><span style="color:#E1E4E8;">        fn.</span><span style="color:#B392F0;">apply</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">arguments</span><span style="color:#E1E4E8;">)  </span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 清空定时器</span></span>
<span class="line"><span style="color:#E1E4E8;">        timer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span></span>
<span class="line"><span style="color:#E1E4E8;">      }, delay)</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">input1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> document.</span><span style="color:#B392F0;">getElementById</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;input1&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 使用debounce生成一个函数</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 如果要是用之前fn里面的this，这里不能使用箭头函数</span></span>
<span class="line"><span style="color:#E1E4E8;">  input1.</span><span style="color:#B392F0;">addEventListener</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;keyup&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#B392F0;">debounce</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">e</span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(e.target)  </span><span style="color:#6A737D;">// 如果不传arguments，在这里无法识别e，也就无法获取当前dom</span></span>
<span class="line"><span style="color:#E1E4E8;">      console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(input1.value);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }), </span><span style="color:#79B8FF;">600</span><span style="color:#E1E4E8;">)  </span><span style="color:#6A737D;">// 不传默认500ms，传的话就覆盖</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">input</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">type</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;text&quot;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">id</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;input1&quot;</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">script</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 监听键盘输入</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">/* const input1 = document.getElementById(&#39;input1&#39;);</span></span>
<span class="line"><span style="color:#6A737D;">  input1.addEventListener(&#39;keyup&#39;, function() {</span></span>
<span class="line"><span style="color:#6A737D;">      console.log(input1.value);  // 每一次按键都会打印</span></span>
<span class="line"><span style="color:#6A737D;">  }) */</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;">   * 体验防抖</span></span>
<span class="line"><span style="color:#6A737D;">   */</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 如果每次按键都走一次请求会非常糟糕</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 实现输入完停顿一段时间(比如半秒)，再做操作(打印或者请求)</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 这个机制(需求)就是防抖</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 需要用到定时器 =&gt; 实际上就是定时器的一种应用</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">input1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> document.</span><span style="color:#6F42C1;">getElementById</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;input1&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> timer  </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  input1.</span><span style="color:#6F42C1;">addEventListener</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;keyup&#39;</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">function</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 比如输入123,</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 输入1，此时timeer不存在，timer赋值定时器id(1)，并把方法加入异步队列，等待时机执行</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 马上输入2，此时timer存在，但异步队列中的方法还未执行(时机未到)，清除定时器(即1的定时任务)，赋值定时器id(2)，，并把方法加入异步队列，等待时机执行</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 马上输入3，同理</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 停止输入，即超过500毫秒，触发定时器任务，获取value值并打印</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 清空定时器</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(timer) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6F42C1;">clearTimeout</span><span style="color:#24292E;">(timer)</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 一直输入，只要中间间断不超过500毫秒，就不会打印</span></span>
<span class="line"><span style="color:#24292E;">    timer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">setTimeout</span><span style="color:#24292E;">(()</span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 模拟触发change事件</span></span>
<span class="line"><span style="color:#24292E;">      console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(input1.value);  </span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 清空定时器</span></span>
<span class="line"><span style="color:#24292E;">      timer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span></span>
<span class="line"><span style="color:#24292E;">    }, </span><span style="color:#005CC5;">500</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">  })</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;">   * 封装防抖</span></span>
<span class="line"><span style="color:#6A737D;">   */</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// debounce是对函数的封装，最终返回的应该也是一个函数</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 延迟时间默认500毫秒</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">debounce</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (</span><span style="color:#E36209;">fn</span><span style="color:#24292E;">, </span><span style="color:#E36209;">delay</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">500</span><span style="color:#24292E;">)</span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// timer是在闭包中的 =&gt; 下面的if(timer)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 这样不会被外界轻易拿到 =&gt; 即不对外暴露</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 我们在外面使用不需要关心</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 同时也是在debounce的作用域中</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 闭包的使用场景：函数当做返回值或者参数传入</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> timer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 函数作为返回值，这就形成闭包了</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 这里面的timer需要在它定义的作用域往上寻找</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(timer) {</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#6F42C1;">clearTimeout</span><span style="color:#24292E;">(timer)</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">      timer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">setTimeout</span><span style="color:#24292E;">(()</span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 触发change事件</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 第一个参数是改变this指向</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 第二个参数是获取所有的参数</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// apply第二个参数开始，只接收数组</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// fn函数在执行的时候，argument传进来</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// debounce返回的函数可能会传进来一些参数</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 面试使用fn()也没问题</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// fn()</span></span>
<span class="line"><span style="color:#24292E;">        fn.</span><span style="color:#6F42C1;">apply</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">arguments</span><span style="color:#24292E;">)  </span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 清空定时器</span></span>
<span class="line"><span style="color:#24292E;">        timer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span></span>
<span class="line"><span style="color:#24292E;">      }, delay)</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">input1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> document.</span><span style="color:#6F42C1;">getElementById</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;input1&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 使用debounce生成一个函数</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 如果要是用之前fn里面的this，这里不能使用箭头函数</span></span>
<span class="line"><span style="color:#24292E;">  input1.</span><span style="color:#6F42C1;">addEventListener</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;keyup&#39;</span><span style="color:#24292E;">, </span><span style="color:#6F42C1;">debounce</span><span style="color:#24292E;">(</span><span style="color:#E36209;">e</span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(e.target)  </span><span style="color:#6A737D;">// 如果不传arguments，在这里无法识别e，也就无法获取当前dom</span></span>
<span class="line"><span style="color:#24292E;">      console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(input1.value);</span></span>
<span class="line"><span style="color:#24292E;">  }), </span><span style="color:#005CC5;">600</span><span style="color:#24292E;">)  </span><span style="color:#6A737D;">// 不传默认500ms，传的话就覆盖</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#22863A;">script</span><span style="color:#24292E;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br></div></div></li></ul><h4 id="_3-2-6-节流-throttle" tabindex="-1">3.2.6. 节流(throttle) <a class="header-anchor" href="#_3-2-6-节流-throttle" aria-label="Permalink to &quot;3.2.6. 节流(throttle)&quot;">​</a></h4><ul><li>场景 <ul><li>拖拽一个元素时，要随时拿到该元素被拖拽的位置</li><li>直接用drag事件，则会频繁触发，很容易造成卡顿</li><li>节流：无论拖拽速度多快，都会每隔100ms触发一次</li></ul></li><li>节流机制简述 <ul><li>节流机制指的是频繁输入或者频繁操作的时候，保持一个频率，连续触发</li></ul></li><li>手写节流 <ul><li><a href="https://zmx2321.github.io/blog_code/interview/interview-one-side/example/run-fun/%E8%8A%82%E6%B5%81(throttle).html" target="_blank" rel="noreferrer">手写demo传送门</a></li></ul><div class="language-html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">style</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">#div1</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">width</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">200</span><span style="color:#F97583;">px</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">height</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">100</span><span style="color:#F97583;">px</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">border</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">1</span><span style="color:#F97583;">px</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">solid</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">#ccc</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">background</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">#f00</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">style</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">id</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;div1&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">draggable</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;true&quot;</span><span style="color:#E1E4E8;">&gt;可拖拽&lt;/</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#6A737D;">// 监听拖拽</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">/* const div1 = document.getElementById(&#39;div1&#39;);</span></span>
<span class="line"><span style="color:#6A737D;">  div1.addEventListener(&#39;drag&#39;, function(e) {</span></span>
<span class="line"><span style="color:#6A737D;">    // 每次移动都会频繁打印</span></span>
<span class="line"><span style="color:#6A737D;">    console.log(e.offsetX, e.offsetY);  // 打印坐标</span></span>
<span class="line"><span style="color:#6A737D;">  }) */</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;">   * 体验节流</span></span>
<span class="line"><span style="color:#6A737D;">   */</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">div1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> document.</span><span style="color:#B392F0;">getElementById</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;div1&#39;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> timer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span></span>
<span class="line"><span style="color:#E1E4E8;">  div1.</span><span style="color:#B392F0;">addEventListener</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;drag&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 拖拽是永远不间断进行的，即连续触发</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 第一次没值，但马上就有值了</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 但只要有值就return出去</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 等下面100ms到了，timer被赋值成null，这个if就不执行</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(timer) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 给timer赋值一个定时器</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 100ms没到的时候，里面方法没执行，定时器就不会被赋值成null</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 100ms到了，打印，赋值成null</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// if不执行，重新生成一个定时任务,timer有值，return</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 直到定时任务执行之前都return</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 执行完定时任务，timer又为null</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 再次生成一个定时任务</span></span>
<span class="line"><span style="color:#E1E4E8;">    timer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">setTimeout</span><span style="color:#E1E4E8;">(()</span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 每次移动都会频繁打印</span></span>
<span class="line"><span style="color:#E1E4E8;">      console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(e.offsetX, e.offsetY)  </span><span style="color:#6A737D;">// 打印坐标</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">      timer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span></span>
<span class="line"><span style="color:#E1E4E8;">    }, </span><span style="color:#79B8FF;">100</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">  })</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;">   * 封装节流</span></span>
<span class="line"><span style="color:#6A737D;">   */</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">throttle</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">fn</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">delay</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">100</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> timer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 这个timer是在闭包里面的</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如果不使用apply改变this指向，下面的throttle方法的参数指向这个函数</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 不会传给下面的那个fn</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(timer) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">      timer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">setTimeout</span><span style="color:#E1E4E8;">(()</span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 一般写一个事件，function里面都要加上event参数，即事件对象</span></span>
<span class="line"><span style="color:#E1E4E8;">        fn.</span><span style="color:#B392F0;">apply</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">arguments</span><span style="color:#E1E4E8;">)  </span><span style="color:#6A737D;">// 打印坐标</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        timer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span></span>
<span class="line"><span style="color:#E1E4E8;">      }, delay)</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">div1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> document.</span><span style="color:#B392F0;">getElementById</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;div1&#39;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 如果用this指向，不能用箭头函数</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 上面如果不加arguments，这里无法获取坐标</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 如果不改变this指向，throttle方法里面的参数会传给throttle返回的那个函数</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// event这个事件对象是传给return的这个函数的，再由这个函数传给fn的</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// throttle里面的这个函数是fn，需要有事件对象</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 事件监听有事件对象，事件对象一般是监听事件里面的参数，这里的事件对象在throttle的返回值中，即return里面的this</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 所以fn.apply(this, arguments)意思是把fn函数的this指向事件对象，并传入所有参数</span></span>
<span class="line"><span style="color:#E1E4E8;">  div1.</span><span style="color:#B392F0;">addEventListener</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;drag&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#B392F0;">throttle</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">);  </span><span style="color:#6A737D;">// 箭头函数指向父级，即当前函数所在环境，即window</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(e.offsetX, e.offsetY)  </span><span style="color:#6A737D;">// 打印坐标</span></span>
<span class="line"><span style="color:#E1E4E8;">  }), </span><span style="color:#79B8FF;">2000</span><span style="color:#E1E4E8;">)  </span><span style="color:#6A737D;">// 不传默认100</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">style</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">#div1</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">width</span><span style="color:#24292E;">: </span><span style="color:#005CC5;">200</span><span style="color:#D73A49;">px</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">height</span><span style="color:#24292E;">: </span><span style="color:#005CC5;">100</span><span style="color:#D73A49;">px</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">border</span><span style="color:#24292E;">: </span><span style="color:#005CC5;">1</span><span style="color:#D73A49;">px</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">solid</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">#ccc</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">background</span><span style="color:#24292E;">: </span><span style="color:#005CC5;">#f00</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#22863A;">style</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">div</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">id</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;div1&quot;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">draggable</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;true&quot;</span><span style="color:#24292E;">&gt;可拖拽&lt;/</span><span style="color:#22863A;">div</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">script</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#6A737D;">// 监听拖拽</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">/* const div1 = document.getElementById(&#39;div1&#39;);</span></span>
<span class="line"><span style="color:#6A737D;">  div1.addEventListener(&#39;drag&#39;, function(e) {</span></span>
<span class="line"><span style="color:#6A737D;">    // 每次移动都会频繁打印</span></span>
<span class="line"><span style="color:#6A737D;">    console.log(e.offsetX, e.offsetY);  // 打印坐标</span></span>
<span class="line"><span style="color:#6A737D;">  }) */</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;">   * 体验节流</span></span>
<span class="line"><span style="color:#6A737D;">   */</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">div1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> document.</span><span style="color:#6F42C1;">getElementById</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;div1&#39;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> timer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span></span>
<span class="line"><span style="color:#24292E;">  div1.</span><span style="color:#6F42C1;">addEventListener</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;drag&#39;</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">function</span><span style="color:#24292E;">(</span><span style="color:#E36209;">e</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 拖拽是永远不间断进行的，即连续触发</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 第一次没值，但马上就有值了</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 但只要有值就return出去</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 等下面100ms到了，timer被赋值成null，这个if就不执行</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(timer) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 给timer赋值一个定时器</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 100ms没到的时候，里面方法没执行，定时器就不会被赋值成null</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 100ms到了，打印，赋值成null</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// if不执行，重新生成一个定时任务,timer有值，return</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 直到定时任务执行之前都return</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 执行完定时任务，timer又为null</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 再次生成一个定时任务</span></span>
<span class="line"><span style="color:#24292E;">    timer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">setTimeout</span><span style="color:#24292E;">(()</span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 每次移动都会频繁打印</span></span>
<span class="line"><span style="color:#24292E;">      console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(e.offsetX, e.offsetY)  </span><span style="color:#6A737D;">// 打印坐标</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">      timer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span></span>
<span class="line"><span style="color:#24292E;">    }, </span><span style="color:#005CC5;">100</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">  })</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;">   * 封装节流</span></span>
<span class="line"><span style="color:#6A737D;">   */</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">throttle</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (</span><span style="color:#E36209;">fn</span><span style="color:#24292E;">, </span><span style="color:#E36209;">delay</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">100</span><span style="color:#24292E;">)</span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> timer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 这个timer是在闭包里面的</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果不使用apply改变this指向，下面的throttle方法的参数指向这个函数</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 不会传给下面的那个fn</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(timer) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">      timer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">setTimeout</span><span style="color:#24292E;">(()</span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 一般写一个事件，function里面都要加上event参数，即事件对象</span></span>
<span class="line"><span style="color:#24292E;">        fn.</span><span style="color:#6F42C1;">apply</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">arguments</span><span style="color:#24292E;">)  </span><span style="color:#6A737D;">// 打印坐标</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        timer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span></span>
<span class="line"><span style="color:#24292E;">      }, delay)</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">div1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> document.</span><span style="color:#6F42C1;">getElementById</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;div1&#39;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 如果用this指向，不能用箭头函数</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 上面如果不加arguments，这里无法获取坐标</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 如果不改变this指向，throttle方法里面的参数会传给throttle返回的那个函数</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// event这个事件对象是传给return的这个函数的，再由这个函数传给fn的</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// throttle里面的这个函数是fn，需要有事件对象</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 事件监听有事件对象，事件对象一般是监听事件里面的参数，这里的事件对象在throttle的返回值中，即return里面的this</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 所以fn.apply(this, arguments)意思是把fn函数的this指向事件对象，并传入所有参数</span></span>
<span class="line"><span style="color:#24292E;">  div1.</span><span style="color:#6F42C1;">addEventListener</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;drag&#39;</span><span style="color:#24292E;">, </span><span style="color:#6F42C1;">throttle</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">function</span><span style="color:#24292E;">(</span><span style="color:#E36209;">e</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">);  </span><span style="color:#6A737D;">// 箭头函数指向父级，即当前函数所在环境，即window</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(e.offsetX, e.offsetY)  </span><span style="color:#6A737D;">// 打印坐标</span></span>
<span class="line"><span style="color:#24292E;">  }), </span><span style="color:#005CC5;">2000</span><span style="color:#24292E;">)  </span><span style="color:#6A737D;">// 不传默认100</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#22863A;">script</span><span style="color:#24292E;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br></div></div></li></ul><h3 id="_3-3-安全" tabindex="-1">3.3. 安全 <a class="header-anchor" href="#_3-3-安全" aria-label="Permalink to &quot;3.3. 安全&quot;">​</a></h3><h4 id="_3-3-1-简述" tabindex="-1">3.3.1. 简述 <a class="header-anchor" href="#_3-3-1-简述" aria-label="Permalink to &quot;3.3.1. 简述&quot;">​</a></h4><ul><li>最常见的web前端攻击方式 <ul><li>XSS跨站请求攻击</li><li>XSRF跨站请求伪造</li></ul></li></ul><h4 id="_3-3-2-xss跨站请求攻击" tabindex="-1">3.3.2. XSS跨站请求攻击 <a class="header-anchor" href="#_3-3-2-xss跨站请求攻击" aria-label="Permalink to &quot;3.3.2. XSS跨站请求攻击&quot;">​</a></h4><ul><li>xss场景 <ul><li>一个博客网站，发表一篇博客，其中嵌入<code>&lt;script&gt;</code>脚本</li><li>脚本内容：获取cookie，发送到我的服务器(服务器配合跨域) <ul><li>cookie里面有个人的敏感信息</li><li>即发布这篇博客，有人查看它，很轻松地就可以收割访问者的cookie</li></ul></li></ul></li><li>xss示例 <ul><li><a href="https://zmx2321.github.io/blog_code/interview/interview-one-side/example/run-fun/XSS%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E6%94%BB%E5%87%BB.html" target="_blank" rel="noreferrer">手写demo传送门</a></li></ul><div class="language-html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 先设置cookie做模拟</span></span>
<span class="line"><span style="color:#E1E4E8;">  document.cookie</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&quot;a=100&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  document.cookie</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&quot;b=200&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  document.cookie</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&quot;userid=xxx&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(document.cookie)</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">body</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;</span><span style="color:#85E89D;">p</span><span style="color:#E1E4E8;">&gt;一段文字1&lt;/</span><span style="color:#85E89D;">p</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;</span><span style="color:#85E89D;">p</span><span style="color:#E1E4E8;">&gt;一段文字2&lt;/</span><span style="color:#85E89D;">p</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;</span><span style="color:#85E89D;">p</span><span style="color:#E1E4E8;">&gt;一段文字3&lt;/</span><span style="color:#85E89D;">p</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span><span style="color:#B392F0;">alert</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;获取cookie信息：&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> document.cookie);&lt;/</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">&lt;!-- 使用特殊字符就不会被获取 --&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">&lt;!-- &amp;lt;script&amp;gt;alert(document.cookie);&amp;lt;/script&amp;gt; --&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">body</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">script</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 先设置cookie做模拟</span></span>
<span class="line"><span style="color:#24292E;">  document.cookie</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;a=100&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  document.cookie</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;b=200&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  document.cookie</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;userid=xxx&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(document.cookie)</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#22863A;">script</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">body</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  &lt;</span><span style="color:#22863A;">p</span><span style="color:#24292E;">&gt;一段文字1&lt;/</span><span style="color:#22863A;">p</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  &lt;</span><span style="color:#22863A;">p</span><span style="color:#24292E;">&gt;一段文字2&lt;/</span><span style="color:#22863A;">p</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  &lt;</span><span style="color:#22863A;">p</span><span style="color:#24292E;">&gt;一段文字3&lt;/</span><span style="color:#22863A;">p</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  &lt;</span><span style="color:#22863A;">script</span><span style="color:#24292E;">&gt;</span><span style="color:#6F42C1;">alert</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;获取cookie信息：&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> document.cookie);&lt;/</span><span style="color:#22863A;">script</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">&lt;!-- 使用特殊字符就不会被获取 --&gt;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">&lt;!-- &amp;lt;script&amp;gt;alert(document.cookie);&amp;lt;/script&amp;gt; --&gt;</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#22863A;">body</span><span style="color:#24292E;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div></li><li>xss预防 <ul><li>替换特殊字符 <ul><li><code>&lt;</code> =&gt; <code>&amp;lt;</code></li><li><code>&gt;</code> =&gt; <code>&amp;gt;</code></li><li>即<code>&lt;script&gt;</code> =&gt; <code>&amp;lt;script&amp;gt;</code>，显示在页面上，且不会被作为脚本执行</li></ul></li><li>前端要替换，后端也要替换</li><li>可以在npm官网找相关工具 =&gt; xss工具 <ul><li>将需要替换的内容当参数传进里面的方法，就可以进行替换了</li></ul></li></ul></li></ul><h4 id="_3-3-3-xsrf跨站请求伪造" tabindex="-1">3.3.3. XSRF跨站请求伪造 <a class="header-anchor" href="#_3-3-3-xsrf跨站请求伪造" aria-label="Permalink to &quot;3.3.3. XSRF跨站请求伪造&quot;">​</a></h4><ul><li>XSRF场景 <ul><li>你正在购物，看中了某个商品，商品id是100</li><li>打算买，但还没有买</li><li>付费接口是<code>xxx/pay?id=100</code>，但没有任何验证</li><li>我是攻击者，我看中了一个商品，id是200</li><li>我现在想让你给我买</li><li>向你发送一封电子邮件，邮件标题很吸引人</li><li>但邮件正文隐藏着<code>&lt;img src=&quot;xxx.com/pay?id=200&quot;&gt;</code></li><li>你一查看邮件，就帮我购买了id是200的商品 <ul><li>正在购物，肯定已经登陆了购物网站，即有了用户信息(cookie)</li><li>打开电子邮件的时候图片的src是自动执行的</li><li>img发送的请求是支持跨域的，所以一打开邮件，你的用户信息就已经被带过去了</li></ul></li></ul></li><li>XSRF预防 <ul><li>使用post接口 <ul><li>使用post接口，img攻击是无效的，即img的跨域攻击在这里没有效果</li><li>在post接口做跨域，只能server端支持</li></ul></li><li>增加验证，例如密码、短信验证码、指纹等</li></ul></li></ul><h2 id="_4-面试题解答-总结" tabindex="-1">4. 面试题解答(总结) <a class="header-anchor" href="#_4-面试题解答-总结" aria-label="Permalink to &quot;4. 面试题解答(总结)&quot;">​</a></h2><h3 id="_4-1-网页加载过程" tabindex="-1">4.1. 网页加载过程 <a class="header-anchor" href="#_4-1-网页加载过程" aria-label="Permalink to &quot;4.1. 网页加载过程&quot;">​</a></h3><ul><li>从输入url到渲染出页面的整个过程 <ul><li>下载资源：各个资源类型，下载过程</li><li>渲染页面：结合html、css、js等</li></ul></li><li>window.onload和DOMContentLoaded的区别 <ul><li>window.onload是资源全部加载完才能执行，包括图片</li><li>DOMContentLoaded是DOM渲染完成即可，图片可能尚未渲染</li></ul></li><li>加载资源的形式 <ul><li>网页是通过html、css、img、js等待这些形式加载资源的</li></ul></li><li>加载资源的过程 <ul><li>dns解析域名到ip =&gt; 浏览器发送http请求到服务端(三次握手) =&gt; 服务端再响应请求到客户端(四次挥手) =&gt; 渲染页面</li></ul></li><li>渲染页面过程 <ul><li>浏览器根据html代码生成DOM</li><li>浏览器根据css代码生成cssOM</li><li>将DOM Tree和cssOM整合形成Render Tree</li><li>浏览器根据Render Tree渲染页面</li><li>遇到js暂停渲染，优先执行js，执行完之后继续渲染</li></ul></li></ul><h3 id="_4-2-性能和体验的优化" tabindex="-1">4.2. 性能和体验的优化 <a class="header-anchor" href="#_4-2-性能和体验的优化" aria-label="Permalink to &quot;4.2. 性能和体验的优化&quot;">​</a></h3><ul><li>性能优化原则是什么 <ul><li>性能优化主要目的就是使页面加载更快更流畅</li><li>多使用内存、缓存、或其他方法</li><li>减少CPU计算量，减少网络加载耗时，即可以使用空间换时间， <ul><li>例如浏览器，一个标签页就是一个进程</li></ul></li></ul></li><li>怎么样让加载更快，举例说明 <ul><li>减少资源体积：压缩代码</li><li>减少访问次数：合并代码、雪碧图、ssr服务端渲染、缓存</li><li>使用更快的网络：CDN <ul><li>域名匹配离你最近的ip</li></ul></li></ul></li><li>怎么样让渲染更快，举例说明 <ul><li>CSS放在head，JS放在body最下面</li><li>用DOMContentLoaded触发js，即在图片等静态资源加载前触发</li><li>懒加载</li><li>对DOM查询进行缓存</li><li>频繁DOM操作，使用代码片段合并到一起插入DOM结构 <ul><li>createDocumentFragment</li></ul></li><li>使用节流和防抖优化渲染体验</li></ul></li><li>防抖是什么，举例说明，手写防抖 <ul><li>防抖机制指的是频繁输入或者频繁操作的时候，最后触发</li><li>手写见上</li></ul></li><li>节流是什么，举例说明，手写节流 <ul><li>节流机制指的是频繁输入或者频繁操作的时候，保持一个频率，连续触发</li><li>手写见上</li></ul></li></ul><h3 id="_4-3-安全" tabindex="-1">4.3. 安全 <a class="header-anchor" href="#_4-3-安全" aria-label="Permalink to &quot;4.3. 安全&quot;">​</a></h3><ul><li>常见的web前端攻击方式有哪些 <ul><li>XSS跨站请求攻击</li><li>XSRF跨站请求伪造</li></ul></li><li>怎么去预防这些攻击 <ul><li>XSS跨站请求攻击 =&gt; 标签用特殊字符表示</li><li>XSRF跨站请求伪造 =&gt; 用post请求，并添加验证</li></ul></li></ul>`,48),e=[o];function t(c,r,i,E,y,u){return n(),l("div",null,e)}const d=s(p,[["render",t]]);export{m as __pageData,d as default};
