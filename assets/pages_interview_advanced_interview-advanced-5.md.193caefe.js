import{_ as s,o as n,c as a,e as l}from"./app.2ecb963c.js";const d=JSON.parse('{"title":"对大前端的思考","description":"","frontmatter":{},"headers":[],"relativePath":"pages/interview/advanced/interview-advanced-5.md","filePath":"pages/interview/advanced/interview-advanced-5.md","lastUpdated":1742540258000}'),p={name:"pages/interview/advanced/interview-advanced-5.md"},e=l(`<h1 id="对大前端的思考" tabindex="-1">对大前端的思考 <a class="header-anchor" href="#对大前端的思考" aria-label="Permalink to &quot;对大前端的思考&quot;">​</a></h1><h2 id="架构师" tabindex="-1">架构师 <a class="header-anchor" href="#架构师" aria-label="Permalink to &quot;架构师&quot;">​</a></h2><ul><li>客户的想法(需求)和执行人(开发)直接有一段距离,这个距离就需要架构师的工作</li><li>架构师的工作就是把客户的想法和执行人的想法连接起来,把客户的想法和执行人的想法连接起来</li><li>架构师做的就是结构的设计与实现,需要具备解决复杂问题的能力</li></ul><h2 id="分析vue的架构" tabindex="-1">分析vue的架构 <a class="header-anchor" href="#分析vue的架构" aria-label="Permalink to &quot;分析vue的架构&quot;">​</a></h2><ul><li>目标: 分析vue的架构,了解vue的架构设计,了解vue的架构设计的目的和意义</li><li>实现</li></ul><h3 id="目标" tabindex="-1">目标 <a class="header-anchor" href="#目标" aria-label="Permalink to &quot;目标&quot;">​</a></h3><ul><li>vue框架的最大的特点是什么 <ul><li>可以实现视图和数据的关联</li></ul></li><li>什么是视图 <ul><li>视图可以算是虚拟dom,也算是一种数据</li><li>就是数据和数据的关联</li><li>但数据和数据关联不存在,例如excel,求和之后,那个单元格背后其实是一个求和公式</li><li>即是数据与计算的关联</li><li>我们需要将视图的意思尽量往计算的方向去靠拢</li><li>得出结论 <ul><li>创建视图的过程和数据发生了关联</li></ul></li><li>而过程,一般表现为函数或者方法,即创建视图的函数与数据产生了关联</li></ul></li><li>创建视图的方法,我们假设叫他render <ul><li>希望函数用到的数据发生变化的时候,render函数会重新执行,返回修改后的数据,这样就实现了视图和数据的关联</li><li>函数运行过程中用到了哪些数据,就关联哪些数据</li><li>与函数运行过程中用到的标记数据产生关联</li><li>需要建立对应关系(函数-数据)</li></ul></li><li>总结 <ul><li>vue框架的最大的特点可以被描述为: 函数运行过程中用到的标记数据,与函数产生关联,需要建立对应关系(函数-数据) <ul><li>监听数据的读取和修改</li><li>如何知晓数据对应的函数 <ul><li>建立对应关系就是依赖收集</li></ul></li></ul></li></ul></li></ul><h4 id="监听数据的读取和修改" tabindex="-1">监听数据的读取和修改 <a class="header-anchor" href="#监听数据的读取和修改" aria-label="Permalink to &quot;监听数据的读取和修改&quot;">​</a></h4><blockquote><p>有2种方式 这两个东西都要求数据是对象</p></blockquote><ul><li>defineProperty <ul><li>监听的范围很窄,只能监听对象的属性</li><li>只能通过属性描述符监听已有属性的描述和修改</li><li>优点是兼容性更好</li></ul></li><li>proxy <ul><li>监听的范围很广</li><li>语法层面的书写,会转变为内部方法的调用 <ul><li><code>data.a = 1 =&gt; Reflect.set(data, &#39;a&#39;, 1)</code></li><li><code>a in data =&gt; Reflect.has(data, &#39;a&#39;)</code></li></ul></li><li>这些内部方法都可以被proxy进行拦截</li><li>es6的语法,可以使用proxy进行监听,不兼容低版本浏览器</li><li>这个被标记的数据在vue里面被称之为响应式数据</li><li>响应式数据就是,当这个数据发生改变的时候,重新运行一次这个函数</li></ul></li><li>用简单的例子描述被用到的数据(即需要被响应式的数据)</li></ul><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> data1 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">, data2, data3</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">fn</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> ()</span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(data1) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    data2  </span><span style="color:#6A737D;">// data2是被用到的数据,需要被响应式</span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    data3  </span><span style="color:#6A737D;">// 不用被关联,不需要响应式</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 在vue里面,表示一个被标记的响应式数据</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> proxyData </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">tag</span><span style="color:#E1E4E8;">(data)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">tag</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">data</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Proxy</span><span style="color:#E1E4E8;">(data, {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">target</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">key</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 返回对象的属性值</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> target[key]</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 依赖收集</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 当数据被读取的时候,需要收集依赖了该数据的函数</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 即当数据被读取的时候,需要收集使用了这个数据的函数</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 这个函数就是当前的函数</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#B392F0;">track</span><span style="color:#E1E4E8;">(target, key)</span></span>
<span class="line"><span style="color:#E1E4E8;">    },</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">set</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">target</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">key</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">value</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 设置对象的属性值</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// target[key] = value</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 建议使用反射赋值,因为它本身会返回一个布尔值</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 赋值成功返回true,失败返回false</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> Reflect.</span><span style="color:#B392F0;">set</span><span style="color:#E1E4E8;">(target, key, value)</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 对应函数重新执行的过程,我们称之为派发更新</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 需要对哪个对象的哪个属性进行派发更新,就需要知道这个对象的哪个属性</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#B392F0;">tigger</span><span style="color:#E1E4E8;">(target, key)</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  })</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 在vue3里面,这个tag方法名字叫做reactive方法</span></span>
<span class="line"><span style="color:#6A737D;">// 即</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> proxyData </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">reactive</span><span style="color:#E1E4E8;">(data)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> data1 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">, data2, data3</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">fn</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> ()</span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(data1) {</span></span>
<span class="line"><span style="color:#24292E;">    data2  </span><span style="color:#6A737D;">// data2是被用到的数据,需要被响应式</span></span>
<span class="line"><span style="color:#24292E;">  } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    data3  </span><span style="color:#6A737D;">// 不用被关联,不需要响应式</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 在vue里面,表示一个被标记的响应式数据</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> proxyData </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">tag</span><span style="color:#24292E;">(data)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">tag</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (</span><span style="color:#E36209;">data</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Proxy</span><span style="color:#24292E;">(data, {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(</span><span style="color:#E36209;">target</span><span style="color:#24292E;">, </span><span style="color:#E36209;">key</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 返回对象的属性值</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> target[key]</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 依赖收集</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 当数据被读取的时候,需要收集依赖了该数据的函数</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 即当数据被读取的时候,需要收集使用了这个数据的函数</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 这个函数就是当前的函数</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6F42C1;">track</span><span style="color:#24292E;">(target, key)</span></span>
<span class="line"><span style="color:#24292E;">    },</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">set</span><span style="color:#24292E;">(</span><span style="color:#E36209;">target</span><span style="color:#24292E;">, </span><span style="color:#E36209;">key</span><span style="color:#24292E;">, </span><span style="color:#E36209;">value</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 设置对象的属性值</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// target[key] = value</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 建议使用反射赋值,因为它本身会返回一个布尔值</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 赋值成功返回true,失败返回false</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> Reflect.</span><span style="color:#6F42C1;">set</span><span style="color:#24292E;">(target, key, value)</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 对应函数重新执行的过程,我们称之为派发更新</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 需要对哪个对象的哪个属性进行派发更新,就需要知道这个对象的哪个属性</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6F42C1;">tigger</span><span style="color:#24292E;">(target, key)</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  })</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 在vue3里面,这个tag方法名字叫做reactive方法</span></span>
<span class="line"><span style="color:#6A737D;">// 即</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> proxyData </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">reactive</span><span style="color:#24292E;">(data)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br></div></div><ul><li>effect.js</li></ul><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 依赖收集</span></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">track</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">target</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">key</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 派发更新</span></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">tigger</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">target</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">key</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 依赖收集</span></span>
<span class="line"><span style="color:#D73A49;">export</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">track</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (</span><span style="color:#E36209;">target</span><span style="color:#24292E;">, </span><span style="color:#E36209;">key</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 派发更新</span></span>
<span class="line"><span style="color:#D73A49;">export</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">tigger</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (</span><span style="color:#E36209;">target</span><span style="color:#24292E;">, </span><span style="color:#E36209;">key</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><ul><li>测试使用</li></ul><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> { reactive } </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;./reactive.js&#39;</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">state</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">reactive</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">  a: </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  b: </span><span style="color:#79B8FF;">2</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">fn</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">  state.a</span></span>
<span class="line"><span style="color:#E1E4E8;">  state.b</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">fn</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">state.a </span><span style="color:#F97583;">++</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> { reactive } </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;./reactive.js&#39;</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">state</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">reactive</span><span style="color:#24292E;">({</span></span>
<span class="line"><span style="color:#24292E;">  a: </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  b: </span><span style="color:#005CC5;">2</span></span>
<span class="line"><span style="color:#24292E;">})</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">fn</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  state.a</span></span>
<span class="line"><span style="color:#24292E;">  state.b</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1;">fn</span><span style="color:#24292E;">()</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">state.a </span><span style="color:#D73A49;">++</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><ul><li>上面reactive.js和effect.js两个内容加起来,就是响应式系统的实现</li><li>响应式系统的目标就是要实现一个函数以及这一块的数据,他们之间建立对应关系</li><li>由于响应式系统的函数,它并不一定是渲染函数,他可以是任何普通函数</li><li>所以响应式系统在整个vue的源吗中是相对独立的</li></ul>`,16),o=[e];function c(r,t,i,E,y,u){return n(),a("div",null,o)}const m=s(p,[["render",c]]);export{d as __pageData,m as default};
//# sourceMappingURL=pages_interview_advanced_interview-advanced-5.md.193caefe.js.map
