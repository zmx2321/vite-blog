# 原理-浏览器渲染原理

## 基本概念信息
- 什么是浏览器的渲染
  - 在浏览器中,将html字符串,转化成像素信息,这个过程就叫渲染
  - 只要将这些像素点的颜色交给gpu,交给显卡,就会在屏幕上显示出来,就完成了一次渲染
    ```js
    const render = (html) => {
        // 屏幕上第一个的第一个像素点什么颜色,第二个像素点什么颜色
        // 第二行.......

        return pixels;
    }
    ```

## 面试题
### 从浏览器输入到页面展示发生了什么
> 主要发生的事情在网络和渲染两个层面,后面我们主要讲渲染
- 网络
  - 浏览器的网络进程会开一个网络线程,去请求这个资源,去拿html字符串
  - 这个网络线程会生成一个渲染任务给渲染进程中的渲染主线程中的消息队列,就启动了一个渲染流程

#### 渲染
> 浏览器是如何渲染页面的？
- 当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。(🌟)
- 在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程
- ---
- 整个渲染流程分为多个阶段，分别是: HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画(🌟)
- 每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。
- 这样，整个渲染流程就形成了一套组织严密的生产流水线。

##### 第一阶段: 解析HTML(生成DOM树和CSSOM树)
- 渲染的第一步是解析 HTML
- 解析过程中遇到 CSS 解析 CSS，遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML中的外部 CSS 文件和 外部的 JS 文件。
- 如果主线程解析到 link 位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。
- 如果主线程解析到 script 位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻搴 HTML 解析的根本原因。
- 第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。
  - 这个dom树的代码实际上是c++代码,外面包了一层,js代码只是用来操作这个dom树
  - 形成dom树是为了后续的工作做准备
- 补充说明: 
  - 有哪些样式表
    - 内部样式表
    - 外部样式表
    - 内联样式表(行内样式表)
    - 浏览器的默认样式表
      - [chrome浏览器源代码](https://github.com/chromium/chromium/blob/main/third_party/blink/renderer/core/html/resources/html.css) 
  - 除了浏览器的默认样式,其他的样式js都能操作
  - styleSheetList对象
    ```js
    {
        styleSheetList: {
            内部样式表: {},
            外部样式表: {},
            内联样式表: {},
            浏览器的默认样式表: {},
        }
    }
    ```
  - 获取样式表: `document.styleSheets`
  - 全局添加样式规则: `document.styleSheets[0].addRule("div", "border: solid 1px #f00")`
    - 框架中使用的比较多
- 问题: 
  - html解析过程中遇到css代码怎么办
    - 为了提高解析效率,浏览器会启动一个预解析器(预解析线程),先下载和解析css文件
  - html解析过程中遇到js代码怎么办
    - 渲染主线程遇到js时必须暂停一切行为,等待下载执行完后才能继续
    - 预解析线程可以分担一点下载js的任务

##### 第二阶段: 样式计算