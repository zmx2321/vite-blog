# 原理-事件循环

## 浏览器的进程模型
> 知道了线程和进程,才能理解浏览器的进程模型,理解了浏览器的进程模型,才能理解事件循环发生在哪个位置,然后才能理解事件循环

### 什么是进程
- 程序运行需要他自己的专属内存空间,可以把这块内存空间简单理解为进程
  - 内存空间,即进程,可以简单理解为房屋 
  - 进程之所以这么设计,它的目的,就是为了隔离,即进程之间是相互隔离的
    - 假如微信崩了,只是微信的专属内存空间被释放掉了,其他程序并没有受到影响
- 每个应用至少有一个进程,进程之间相互独立,即使要通信,也需要双方同意
 
### 什么是线程
- 有了进程之后,就有了内存空间了,就可以运行程序代码了,但是谁来运行代码 ?
  - 运行代码的「人」我们就把它叫做线程
  - 所以一个进程至少有一个线程(即至少有一个人去跑代码)(不然分配了内存空间不干活,这个空间就没用了)
- 进程在开启后会自动创建一个线程来运行代码,我们称这个线程是主线程
  - 如果程序需要同时执行多块代码,主线程就会启动更多的线程来执行代码,所以一个进程中可以包含多个线程 
  - 主线程结束了,整个程序也结束了
- 举个例子(运行一款游戏)
  - 先分配一块内存空间,就是进程,里面有很多个「人」要干事情
    - 他们共享一块内存空间(都是一家人,家里的东西可以随便拿随便用)
  - 主线程(干登陆注册等事情)
  - 游戏线程(游戏的逻辑)
  - 音效线程(游戏的音效)
  - 网络线程(游戏的网络通信)
  - ......

### 浏览器有哪些进程和线程
> 浏览器的进程模型
- 浏览器是一款多进程多线程的应用程序
  - 浏览器的内部工作极其复杂,复杂程度已经堪比一个操作系统了
- 如何看浏览器的进程(任务管理器)
  - 右上角 => 更多工具 => 任务管理器
- 当浏览器启动之后,它会自动启动多个进程,主要有以下几种(每个进程都有独立的内存空间)
  - 浏览器进程
    - 界面展示: 浏览器皮肤,头部,底部,书签栏,地址栏,前进后退,刷新等
    - 用户交互: 鼠标滚动了滚动条,按了键盘,点击了按钮等
    - 子进程管理: 负责启动其他进程,比如渲染进程,插件进程等
      - 浏览器刚启动的时候只有一个浏览器进程,这是主进程,其他所有的进程都是由主进程即浏览器进程启动的
      - 每打开一个标签页,浏览器进程就会启动一个渲染进程,一个网络进程,一个GPU进程等
    - 浏览器进程内部会启用多个线程处理不同的任务
  - 网络进程
    - 负责加载网络资源,比如http请求等. 网络进程内部会启动多个线程处理不同的网络任务
  - 渲染进程(我们需要了解的重点)
    - 浏览器启动之后,会自动打开一个标签页,这个标签页就是一个渲染进程,即一个标签页一个渲染进程
    - 因为每开一个页面就相当于开了一个进程,所以谷歌浏览器特别吃内存,开多了就卡了
    - 目前谷歌浏览器还是这种模式,但将来可能会有变动
    - 按照官方说明,为了减少进程的数量,谷歌浏览器可能会采用「站点隔离」的模式,即一个站点一个渲染进程
-  补充说明
   - 浏览器开启之后,除了以上那些进程还有很多,比如GPU进程,v8代理进程等
   - 浏览器每打开一个Tab页面就会开启一个新的进程,每个进程都是相互独立的,每个进程内都有自己一套完整的JavaScript引擎,DOM,BOM等

#### 渲染进程(我们需要了解的重点)
- 渲染进程启动后,会开启一个渲染主线程
  - 渲染主线程负责执行HTML、JS、CSS代码
  - 默认情况下,浏览器会为每一个标签页开启一个新的渲染进程,以保证不同的标签页之间互不影响
  - 渲染主线程是浏览器中最繁忙的线程,它会执行HTML解析、CSS解析、JavaScript执行、布局(宽高位置)、绘制等任务
    - 计算样式(换算成px,样式冲突等)
    - 执行事件处理函数、定时器回调函数、网络请求回调函数等
    - 每秒把页面画60次,即每16.7ms画一次(fps: 60帧每秒)
    - ......
    - 为什么渲染进程不适用多个线程来处理这些事情,(为什么只能让渲染主线程来处理)?
  - 因为渲染主线程非常繁忙,所以如果渲染主线程被阻塞了,那么页面就会卡顿

#### 渲染主线程
> 要处理那么多的任务,主线程遇到了一个前所未有的难题,如何调度任务,才能保证页面流畅运行
> 渲染主线程使用了一个绝妙的主意来处理这个问题: 排队
- 渲染主线程会按照顺序执行任务,每个任务都有一个优先级,优先级高的任务会优先执行
  - 其他任务会进入队列,等待主线程空闲的时候再执行,这个队列就叫做消息队列
  - 这个队列中的任务,也可能是其他线程派发的(比如用户的交互[我们在前文了解到,用户的交互是由浏览器进程派发的],定时器回调函数,网络请求回调函数等)
    - 其他进程,包括浏览器进程,是不能执行js代码的,只能派发任务给渲染进程的渲染主线程中的消息队列中让其排队执行
  - 这个任务队列,就是浏览器的事件循环机制的核心
- 事件循环(也叫消息循环)
  - 最开始的时候,渲染主线程会进入一个无线循环 => `for(;;)`
  - 每一次循环会检查消息队列中是否有任务存在,如果有,就取出第一个任务,执行碗一个后进入下一次循环,如果没有,则进入休眠状态
  - 其他所有线程(包括其他进程的线程)可以随时向消息队列中添加任务,新任务会驾到消息队列的末尾,在添加新任务时,如果主线程是休眠状态,则会将其唤醒以继续循环拿取任务
- 补充说明
  - 在浏览器源码(c++写的)里面,这个消息队列的文件夹名字,叫做message_loop(消息循环)
  - 在w3c里面叫做 event loop(事件循环)
  - 在谷歌浏览器里面叫做 message loop(消息循环)

## 事件循环的一些解释性说明
### 什么是异步
- 在代码执行中,会遇到一些无法立即处理的任务
  - setTimeout、setInterval、XHR、Fetch、Promise、addEventListener等
  - 如果让渲染主线程需要依次等他们执行完再去做其他的事情,那么页面就会卡顿,用户体验就会非常差
- 举个例子
  - 如果遇到了setTimeout,渲染主线程会将setTimeout的任务派发到其他线程(对渲染主线程来说,这个任务就结束了),然后继续执行后续的任务
    - 这个线程就是计时线程(渲染主线程没有计时的功能)
    - 计时器线程会等待指定的时间,到时间之后,向消息队列中添加一个任务(渲染主线程依次执行任务,执行到它时,就会执行这个任务)
    - 计时器原理比事件循环原理复杂非常多,我们这里只是假定类似一个人在掐着表计时,但实际上里面是操作系统方面的东西,这里不展开讲
    - 这里使用的就是异步,渲染主线程直接把setTimeout的任务派发到其他线程,然后继续执行后续的任务,计时线程掐表到时间之后把这个任务塞到任务队列中
- 渲染主线程承担着极其重要的工作,无论如何不能阻塞
  - 使用异步之后,渲染主线程永不阻塞
- 面试题: 如何理解js的异步
  - js是一门单线程的语言(🌟),这是因为它始终运行在浏览器的渲染主线程中的(🌟),而渲染主线程只有一个,但渲染主线程承担着诸多的工作,如渲染页面,执行js,处理用户交互等(🌟),如果使用同步的方式,就极有可能导致主线程产生阻塞,从而导致消息队列中的很多其他任务无法执行,这样一来,一方面会导致主线程白白消耗时间,另一方面导致页面无法及时更新,给用户产生卡死的现象
  - 所以浏览器采用异步的方式来避免,具体的做法是,当某些任务发生时,如计时器,网络,事件监听等,主线程将任务交给其他线程去处理,自身立即结束任务的执行(🌟),转而执行后续代码,当其他线程完成时,将事先传递的回调函数包装成任务(🌟),加入到消息队列的末尾排队(🌟),等待主线程调度执行(🌟)
  - 在这种异步模式下,渲染主线程,即渲染主进程,即渲染进程,也即浏览器,永不阻塞,从而最大程度保证了单线程的流畅运行
  - js是单线程的原因不是浏览器是单线程的(浏览器是多进程多线程的),是因为只有浏览器的渲染进程中的渲染主线程可以执行js代码,即js是执行在渲染主线程上的
- 补充说明
  - 在浏览器源码中,所有的任务实际上是一个结构体(可以理解成一个对象),任务队列中可以把任务放进去,但不能把一个回调函数放进去

### JS为何会阻碍渲染
> 因为js的执行和页面的渲染,都在渲染主线程中进行的 
```html
<html>
  <body>
    <h1>test! </h1> 
    <button>change</button> 

    <script>
      var h1 = document. querySelector ( 'h1');
      var btn = document. querySelector ('button');
      // 死循环指定的时间
      function delay(duration) {
        var start = Date.now();
        while (Date.now() - start < duration) {}
      }
      btn.onclick = function (){
        h1.textContent ='test0000!'；
        delay (3000);
      }
    </script>
  <body>
</html>
```
- 一开始执行全局js,任务队列是空的,没有任务在排队
- 当渲染主线程执行到`btn.onclick`的时候,会把这个任务派发给交互线程,就不管了,继续执行下面的任务
  - 告诉交互线程,当按钮被点击的时候,要把这个回调函数包装成任务,放到任务队列的末尾
- 当用户点击了按钮
- 函数被放到了消息队列(其实是一个任务对象)
- 渲染主线程开始执行任务
- 首先修改dom的文本内容,在js中设置了,但没在页面中体现
  - 在修改了dom文本之后,需要在页面绘制,于是这个任务派发了一个绘制任务到消息队列
- 到下一步执行死循环
- 死循环结束,开始执行下一个任务,即绘制页面
  - 文本其实早就改了,但需要死循环结束之后才能绘制页面
  - 所以js的执行,会影响页面渲染
- 补充说明
  - react使用了fiber机制,来减少js运行对页面渲染的影响,因为react的fiber机制,会把渲染任务拆分成多个小任务,让渲染任务和js任务交替执行,从而减少js对页面渲染的影响

### 任务有优先级吗
> 任务没有优先级,先进先出
> 但是消息队列有优先级
- w3c的最新解释
  - 随着浏览器的复杂度急剧提升,w3c不再用宏队列的说法,而是用任务队列的说法
  - 每个任务都有一个任务类型,同一个类型的任务必须在一个队列,不同类型的任务可以分属于不同的队列. 在一次事件循环中,浏览器可以根据实际情况从不同的队列中取出任务执行
  - 浏览器必须准备好一个微队列,微队列中的任务优先所有其他任务执行
- 在目前chrome浏览器中,有4个任务队列
  - 微队列: 用户存放需要最快执行的任务,优先级 => 最高 (promie、mutationObserver)
  - 交互队列: 用于存放用户操作后产生的事件处理任务,优先级 => 高
  - 延时队列: 用于存放计时器到达后的回调任务,优先级 => 中
  - 异步队列: 用于存放I/O、网络请求等异步任务,优先级 => 低