# V8是怎么通过内联缓存来提升函数执行效率的

## 问题
- 接上一章思考题
```js
function loadX(o) { 
    return o.x
}
var o = { x: 1,y:3}
var o1 = { x: 3 ,y:6}
for (var i = 0; i < 90000; i++) {
    loadX(o)
    loadX(o1)
}
```
- 我们定义了一个 loadX 函数，它有一个参数 o，该函数只是返回了 o.x。
- 通常 V8 获取 o.x 的流程是这样的：查找对象 o 的隐藏类，再通过隐藏类查找 x 属性偏移量，然后根据偏移量获取属性值，在这段代码中 loadX 函数会被反复执行，那么获取 o.x 流程也需要反复被执行。我们有没有办法再度简化这个查找过程，最好能一步到位查找到 x 的属性值呢？答案是，有的。
- 其实这是一个关于内联缓存的思考题。我们可以看到，函数 loadX 在一个 for 循环里面被重复执行了很多次，因此 V8 会想尽一切办法来压缩这个查找过程，以提升对象的查找效率。这个加速函数执行的策略就是内联缓存 (Inline Cache)，简称为 IC。
- 下面我们就来解答下，V8 是怎么通过 IC，来加速函数 loadX 的执行效率的。

## 什么是内联缓存

## V8内联缓存(IC)知识关系思维导图
<img-viewer :src="'https://zmx2321.github.io/vite-blog/images/note/front/v8-note/17/17-0.png'" :alt="'V8内联缓存(IC)知识关系思维导图'" />